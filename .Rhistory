CalcGTheoryCINested(Data = Brennan.3.1, B = 1000, type = "po")
library(Gboot)
test_boot <- CalcGTheoryCINested(Data = Brennan.3.1, B = 1000, type = "po")
#' Compute confidence intervals for G-theory quantities for the nested model
#'
#' This function computes and stores the raw bootstrap samples for G-theory variance components and coefficients.
#' @param Data Data in long format in the following order: person, facet1, facet2 (facet1 is nested within facet2), score
#' @param B Number of bootstrap iterations
#' @param type Type of bootstrap sampling scheme as described in Tong & Brennan (2004)
#' @return A matrix of bootstrap values which is then given to the summaryCI() function
#' @examples
#' \dontrun{
#' data("Brennan.3.1")
#' CalcGTheoryCINested(Data = Brennan.3.1, B = 1000, type = "po")
#' }
#' @importFrom foreach foreach %dopar%
#' @importFrom doParallel registerDoParallel
#' @importFrom iterators icount
#' @export
CalcGTheoryCINested <- function(Data = NULL, B = 1000,
type = c("p", "o", "po", "io", "pio")) {
if(is.null(Data)) stop("The Data argument has no default.\nPlease specify an object in the specified format")
if(ncol(Data) != 4) stop("Please ensure that your data has only 4 columns, with the columns in the specified order.")
# source("R/calcVarCompNested.R")
# source("R/calcAdjustedVarNested.R")
colnames(Data) <- c("p", "i", "o", "Score")
Data$p <- factor(Data$p)
Data$i <- factor(Data$i)
Data$o <- factor(Data$o)
np <- nlevels(Data$p)
ni <- nlevels(Data$i)
no <- nlevels(Data$o)
results <- NULL
registerDoParallel(cores = (parallel::detectCores() - 1))
r <- foreach(icount(B), .combine = rbind) %dopar% {
switch(type,
"p" = {
## Get indices for p boot-p
boot_indices <- sample(1:np, np, replace = TRUE)
boot_sample <- unlist(sapply(boot_indices, function(x) which(Data$p == x)))
boot_data <- Data[boot_sample, ]
# re-index person
boot_data$p <- Data[order(Data$p), ]$p
# Compute estimated variance components
boot_var <- calcVarCompNested(boot_data)
# Compute adjusted variance component estimates
boot_AdjVar <- calcAdjustedVarNested(boot_data, boot_var[1], boot_var[2], boot_var[3], boot_var[4],
boot_var[5], type = "p")
},
"o" = {
## Get indices for o boot-o
boot_indices <- sample(1:no, no, replace = TRUE)
boot_sample <- unlist(sapply(boot_indices, function(x) which(Data$o == x)))
boot_data <- Data[boot_sample, ]
# re-index occasion
boot_data$o <- Data[order(Data$o), ]$o
# Compute estimated variance components
boot_var <- calcVarCompNested(boot_data)
# Compute adjusted variance component estimates
boot_AdjVar <- calcAdjustedVarNested(boot_data, boot_var[1], boot_var[2], boot_var[3], boot_var[4],
boot_var[5], type = "o")
},
"po" = {
## Get indices for p and o
boot_indices_p <- sample(1:np, np, replace = TRUE)
boot_indices_o <- sample(1:no, no, replace = TRUE)
# draw person
boot_sample_p <- unlist(sapply(boot_indices_p, function(x) which(Data$p == x)))
boot_data_p <- Data[boot_sample_p, ]
# re-index person
boot_data_p$p <- Data[order(Data$p), ]$p
# draw occasion
boot_sample <- unlist(sapply(boot_indices_o, function(x) which(boot_data_p$o == x)))
boot_data <- boot_data_p[boot_sample, ]
# re-index item
boot_data$o <- Data[order(Data$o), ]$o
# Compute estimated variance components
boot_var <- calcVarCompNested(boot_data)
# Compute adjusted variance component estimates
boot_AdjVar <- calcAdjustedVarNested(boot_data, boot_var[1], boot_var[2], boot_var[3], boot_var[4],
boot_var[5], type = "po")
},
"io" = {
## Get indices for o
boot_indices_o <- sample(1:no, no, replace = TRUE)
# draw occasion
boot_sample_o <- unlist(sapply(boot_indices_o, function(x) which(Data$o == x)))
boot_data_o <- Data[boot_sample_o, ]
# re-index occasion
boot_data_o$o <- Data[order(Data$o), ]$o
boot_data <- NULL
for (t in 1:no){
boot_indices_i <- sample(1:ni, ni, replace = TRUE)
# draw item within each occasion
boot_sample <- unlist(sapply(boot_indices_i, function(x) which(boot_data_o[which(boot_data_o[,'o'] == t), ]$i == x)))
boot_data <- rbind(boot_data, boot_data_o[which(boot_data_o[,'o'] == t), ][boot_sample, ])
}
# re-index item
boot_data$i <- Data[order(Data$i), ][order(Data$o), ]$i
# Compute estimated variance components
boot_var <- calcVarCompNested(boot_data)
# Compute adjusted variance component estimates
boot_AdjVar <- calcAdjustedVarNested(boot_data, boot_var[1], boot_var[2], boot_var[3], boot_var[4],
boot_var[5], type = "io")
},
"pio" = {
## Get indices for p
boot_indices_p <- sample(1:np, np, replace = TRUE)
# draw person
boot_sample_p <- unlist(sapply(boot_indices_p, function(x) which(Data$p == x)))
boot_data_p <- Data[boot_sample_p, ]
# re-index person
boot_data_p$p <- Data[order(Data$p), ]$p
## Get indices for o
boot_indices_o <- sample(1:no, no, replace = TRUE)
# draw occasion
boot_sample_o <- unlist(sapply(boot_indices_o, function(x) which(boot_data_p$o == x)))
boot_data_o <- boot_data_p[boot_sample_o, ]
# re-index occasion
boot_data_o$o <- Data[order(Data$o), ]$o
boot_data <- NULL
for (t in 1:no){
boot_indices_i <- sample(1:ni, ni, replace = TRUE)
# draw item within each occasion
boot_sample <- unlist(sapply(boot_indices_i, function(x) which(boot_data_o[which(boot_data_o[,'o'] == t), ]$i == x)))
boot_data <- rbind(boot_data, boot_data_o[which(boot_data_o[,'o'] == t), ][boot_sample, ])
}
# re-index item
boot_data$i <- Data[order(Data$i), ][order(Data$o), ]$i
# Compute estimated variance components
boot_var <- calcVarCompNested(boot_data)
# Compute adjusted variance component estimates
boot_AdjVar <- calcAdjustedVarNested(boot_data, boot_var[1], boot_var[2], boot_var[3], boot_var[4],
boot_var[5], type = "pio")
})
## Compute D-study coefficients, Brennan p. 16
boot_AbsErrVar <- boot_AdjVar[4]/(ni * no) + boot_AdjVar[5]/(ni * no)
boot_GenCoef <- (boot_AdjVar[1] + boot_AdjVar[3]/no)/(boot_AdjVar[1] + boot_AdjVar[3]/no + boot_AdjVar[5]/(ni * no))
boot_DepCoef <- (boot_AdjVar[1] + boot_AdjVar[3]/no)/(boot_AdjVar[1] + boot_AdjVar[3]/no + boot_AbsErrVar)
# Accumulate results such that cols 1-8 are varp,varo,varpo,vario,varpio,
# AbsErrVar,GenCoef,DepCoef
result <- c(boot_AdjVar, boot_AbsErrVar, boot_GenCoef, boot_DepCoef)
result
}
results <- rbind(results, r)
class(results) <- append(class(results), "G_out")
return(results)
}
test_boot <- CalcGTheoryCINested(Data = Brennan.3.1, B = 1000, type = "po")
library(doParallel)
library(foreach)
test_boot <- CalcGTheoryCINested(Data = Brennan.3.1, B = 1000, type = "po")
#' Calculate nested variance components.
#'
#' This function computes 2-facet nested variance components using ANOVA.
#' @param Data Data in long format in the following order: person, facet1, facet2 (facet1 is nested within facet2), score
#' @return A list of variance components
#' @examples
#' \dontrun{
#' data("Brennan.3.1")
#' calcVarCompNested(Data = Brennan.3.1)
#' }
#' @importFrom stats aggregate
#' @export
calcVarCompNested <- function(Data = NULL) {
if(is.null(Data)) stop("The Data argument has no default.\nPlease specify an object in the specified format")
if(ncol(Data) != 4) stop("Please ensure that your data has only 4 columns, with the columns in the specified order.")
## Calculate 2-facet variance components via ANOVA from 'long' data Get sample sizes
colnames(Data) <- c("p", "i", "o", "Score")
Data$p <- factor(Data$p)
Data$i <- factor(Data$i)
Data$o <- factor(Data$o)
np <- nlevels(Data$p)
ni <- nlevels(Data$i)
no <- nlevels(Data$o)
# Compute Sums of Squared Mean Scores (T)
xbar <- mean(Data$Score)
Tp <- no * ni * sum(aggregate(Data[, 4], list(Data$p), mean)[, 2]^2)
To <- np * ni * sum(aggregate(Data[, 4], list(Data$o), mean)[, 2]^2)
Tpo <- ni * sum(aggregate(Data[, 4], list(Data$p, Data$o), mean)[, 3]^2)
Tio <- np * sum(aggregate(Data[, 4], list(Data$o, Data$i), mean)[, 3]^2)
Tpio <- sum(Data$Score^2)
Tmu <- np * ni * no * xbar^2
# Compute Sum of Squares (SS)
SSp <- Tp - Tmu
SSo <- To - Tmu
SSpo <- Tpo - Tp - To + Tmu
SSio <- Tio - To
SSpio <- Tpio - Tpo - Tio + To
# Comupute Mean squares (MS)
MSp <- SSp/(np - 1)
MSo <- SSo/(no - 1)
MSpo <- SSpo/((np - 1) * (no - 1))
MSio <- SSio/(no * (ni - 1))
MSpio <- SSpio/(no * (np - 1) * (ni - 1))
# Compute variance components
var_pio <- MSpio
var_po <- (MSpo - MSpio)/ni
var_io <- (MSio - MSpio)/np
var_p <- (MSp - ni * var_po - MSpio)/(ni * no)
var_o <- (MSo - ni * var_po - np * var_io - MSpio)/(np * ni)
# Return a list of five variance components
var_comp <- c(var_p, var_o, var_po, var_io, var_pio)
names(var_comp) <- c("var_p", "var_o", "var_po", "var_i:o", "var_pio")
return(var_comp)
}
#' Calculate adjusted variance components for the nested model.
#'
#' This is an internal function for CalcGTheoryCINested
#' @param .data Internal input
#' @param .var_p Internal input
#' @param .var_o Internal input
#' @param .var_po Internal input
#' @param .var_io Internal input
#' @param .var_pio Internal input
#' @param type Internal input
#' @export
#'
calcAdjustedVar <- function(.data, .var_p, .var_o, .var_po,
.var_io, .var_pio, type) {
# Calculate adjusted variance components, given data and original components
np <- nlevels(.data$p)
ni <- nlevels(.data$i)
no <- nlevels(.data$o)
switch(type,
"p" = {
adj_var_p <- (np/(np - 1)) * .var_p
adj_var_o <- .var_o - (1/(np - 1)) * .var_po
adj_var_po <- (np/(np - 1)) * .var_po
adj_var_io <- .var_io - (1/(np - 1)) * .var_pio
adj_var_pio <- (np/(np - 1)) * .var_pio
},
"o" = {
adj_var_p <- .var_p - (1/(no - 1)) * .var_po
adj_var_o <- (no/(no - 1)) * .var_o
adj_var_po <- (no/(no - 1)) * .var_po
adj_var_io <- .var_io
adj_var_pio <- .var_pio
},
"po" = {
adj_var_p <- (np/(np - 1)) * .var_p - (np/((np - 1) * (no - 1))) * .var_po
adj_var_o <- (no/(no - 1)) * .var_o - (no/((np - 1) * (no - 1))) * .var_po
adj_var_po <- (np * no/((np - 1) * (no - 1))) * .var_po
adj_var_io <- .var_io - (1/(np - 1)) * .var_pio
adj_var_pio <- np/(np - 1) * .var_pio
},
"io" = {
adj_var_p <- .var_p - (1/(no * (ni - 1))) * .var_pio
adj_var_o <- (no/(no - 1)) * .var_o - 1/(ni - 1) * .var_io
adj_var_po <- (no/(no - 1)) * .var_po - 1/(ni - 1) * .var_pio
adj_var_io <- (ni/(ni - 1)) * .var_io
adj_var_pio <- (ni/(ni - 1)) * .var_pio
},
"pio" = {
adj_var_p <- (np/(np - 1)) * .var_p - (np/((np - 1) * (no - 1))) * .var_po
adj_var_o <- (no/(no - 1)) * .var_o - (no/((np - 1) * (no - 1))) * .var_po - 1/(ni - 1) * .var_io + 1/((np - 1) * (ni - 1)) * .var_pio
adj_var_po <- (np * no/((np - 1) * (no - 1))) * .var_po - np/((np - 1) * (ni - 1)) * .var_pio
adj_var_io <- (ni/(ni - 1)) * .var_io - (ni/((np - 1) * (ni - 1))) * .var_po
adj_var_pio <- np * ni/((np - 1) * (ni - 1)) * .var_pio
})
return(c(adj_var_p, adj_var_o, adj_var_po, adj_var_io, adj_var_pio))
}
test_boot <- CalcGTheoryCINested(Data = Brennan.3.1, B = 1000, type = "po")
#' Calculate adjusted variance components for the nested model.
#'
#' This is an internal function for CalcGTheoryCINested
#' @param .data Internal input
#' @param .var_p Internal input
#' @param .var_o Internal input
#' @param .var_po Internal input
#' @param .var_io Internal input
#' @param .var_pio Internal input
#' @param type Internal input
#' @export
#'
calcAdjustedVar <- function(.data, .var_p, .var_o, .var_po,
.var_io, .var_pio, type) {
# Calculate adjusted variance components, given data and original components
np <- nlevels(.data$p)
ni <- nlevels(.data$i)
no <- nlevels(.data$o)
switch(type,
"p" = {
adj_var_p <- (np/(np - 1)) * .var_p
adj_var_o <- .var_o - (1/(np - 1)) * .var_po
adj_var_po <- (np/(np - 1)) * .var_po
adj_var_io <- .var_io - (1/(np - 1)) * .var_pio
adj_var_pio <- (np/(np - 1)) * .var_pio
},
"o" = {
adj_var_p <- .var_p - (1/(no - 1)) * .var_po
adj_var_o <- (no/(no - 1)) * .var_o
adj_var_po <- (no/(no - 1)) * .var_po
adj_var_io <- .var_io
adj_var_pio <- .var_pio
},
"po" = {
adj_var_p <- (np/(np - 1)) * .var_p - (np/((np - 1) * (no - 1))) * .var_po
adj_var_o <- (no/(no - 1)) * .var_o - (no/((np - 1) * (no - 1))) * .var_po
adj_var_po <- (np * no/((np - 1) * (no - 1))) * .var_po
adj_var_io <- .var_io - (1/(np - 1)) * .var_pio
adj_var_pio <- np/(np - 1) * .var_pio
},
"io" = {
adj_var_p <- .var_p - (1/(no * (ni - 1))) * .var_pio
adj_var_o <- (no/(no - 1)) * .var_o - 1/(ni - 1) * .var_io
adj_var_po <- (no/(no - 1)) * .var_po - 1/(ni - 1) * .var_pio
adj_var_io <- (ni/(ni - 1)) * .var_io
adj_var_pio <- (ni/(ni - 1)) * .var_pio
},
"pio" = {
adj_var_p <- (np/(np - 1)) * .var_p - (np/((np - 1) * (no - 1))) * .var_po
adj_var_o <- (no/(no - 1)) * .var_o - (no/((np - 1) * (no - 1))) * .var_po - 1/(ni - 1) * .var_io + 1/((np - 1) * (ni - 1)) * .var_pio
adj_var_po <- (np * no/((np - 1) * (no - 1))) * .var_po - np/((np - 1) * (ni - 1)) * .var_pio
adj_var_io <- (ni/(ni - 1)) * .var_io - (ni/((np - 1) * (ni - 1))) * .var_po
adj_var_pio <- np * ni/((np - 1) * (ni - 1)) * .var_pio
})
return(c(adj_var_p, adj_var_o, adj_var_po, adj_var_io, adj_var_pio))
}
test_boot <- CalcGTheoryCINested(Data = Brennan.3.1, B = 1000, type = "po")
library(roxygen2)
roxygenise("CalcGTheoryCI")
roxygenise("R/CalcGTheoryCI")
roxygenise("~/Gboot1/R/CalcGTheoryCI")
roxygenise("~/Gboot1/R/CalcGTheoryCI.R")
roxygenise("~/Gboot1")
library(Gboot)
data("Brennan.3.1")
set.seed(123)
test_boot <- CalcGTheoryCINested(Data = Brennan.3.1, B = 1000, type = "po")
sumTest <- summaryCINested(test_boot, 0.80, 4)
roxygenise("~/Gboot1")
library(Gboot)
data("Brennan.3.1")
set.seed(123)
test_boot <- CalcGTheoryCINested(Data = Brennan.3.1, B = 1000, type = "po")
sumTest <- summaryCINested(test_boot, 0.80, 4)
data("Brennan.3.1")
set.seed(123)
test_boot <- CalcGTheoryCINested(Data = Brennan.3.1, B = 1000, type = "po")
summaryCINested(test_boot, 0.80, 4)
data("Brennan.3.1")
set.seed(123)
test_boot <- CalcGTheoryCINested(Data = Brennan.3.1, B = 1000, type = "po")
data("Brennan.3.1")
set.seed(123)
test_boot <- CalcGTheoryCI(Data = Brennan.3.1, B = 1000, type = "po")
summaryCI(test_boot, 0.80, 4)
roxygenise(Gboot)
roxygenise("Gboot")
roxygenise("~/Gboot1")
library(Gboot)
test_boot <- CalcGTheoryCI(Data = Brennan.3.1, B = 1000, type = "pi")
summaryCI(test_boot, 0.80, 3)
test_boot <- CalcGTheoryCINested(Data = Brennan.3.1, B = 1000, type = "pi")
test_boot <- CalcGTheoryCI(Data = Brennan.3.1, B = 1000, type = "pi")
test_boot <- CalcGTheoryCINested(Data = Brennan.3.1, B = 1000, type = "pi")
test_boot <- CalcGTheoryCINested(Data = Brennan.3.1, B = 1000, type = "p")
test_boot <- CalcGTheoryCINested(Data = Brennan.3.1, B = 1000, type = "po")
summaryCINested(test_boot, 0.80, 3)
library(gtheory)
##Simulate data from p x (i:h) design
#set sample sizes
np <- 100 #persons
ni <- 20 #items PER RATER
nh <- 2 #raters
ni.h <- ni/nh #number of i within each h
#set true parameter values to those in Table 7 of Tong & Brennan
sig_p <- 4
sig_h <- 1
sig_ph <- sqrt(2)
sig_i.h <- sqrt(7)
sig_pi.h <- sqrt(208)
#Construct design matrix (only needs to be done once)
sim_data <- data.frame(matrix(0, np*ni*nh, ncol = 4))
colnames(sim_data) <- c("p","i","h","Score")
sim_data$p <- rep(1:np, each = ni*nh)
sim_data$i <- rep(1:ni, times = np*nh) #line of change
sim_data$h <- rep(1:nh, each = ni, times = np)
results <- matrix(0,nrow = 1000, ncol = 5)
for (i in 1:1000){
#Create random effects (generate new for each replication)
Zp <- rnorm(np, 0, 1)
Zh <- rnorm(nh, 0, 1)
Zph <- matrix(rnorm(np*nh, 0, 1), nrow = np, ncol = nh)
Zi.h <- matrix(rnorm(ni*nh, 0, 1), nrow = ni, ncol = nh)
#Simulate Scores
score_index <- 1
for (p_ in 1:np) { #using underscores to differentiate index from variable name
for (h_ in 1:nh) {
for (i_ in 1:ni) {
Score_pih <- sig_p*Zp[p_] +
sig_h*Zh[h_] +
sig_ph*Zph[p_,h_] +
sig_i.h*Zi.h[i_,h_] +
sig_pi.h*rnorm(1)
sim_data$Score[score_index] <- Score_pih
score_index <- score_index + 1
}
}
}
formula <- Score ~ (1|p)+(1|p:h)+ (1|h/i)
g <- gstudy(data = sim_data, formula)
results[i,] <- g$components[,2]
}
colMeans(results)
library(gtheory)
##Simulate data from p x (i:h) design
#set sample sizes
np <- 100 #persons
ni <- 20 #items PER RATER
nh <- 2 #raters
ni.h <- ni/nh #number of i within each h
#set true parameter values to those in Table 7 of Tong & Brennan
sig_p <- 4
sig_h <- 1
sig_ph <- sqrt(2)
sig_i.h <- sqrt(7)
sig_pi.h <- sqrt(208)
#Construct design matrix (only needs to be done once)
sim_data <- data.frame(matrix(0, np*ni*nh, ncol = 4))
colnames(sim_data) <- c("p","i","h","Score")
sim_data$p <- rep(1:np, each = ni*nh)
sim_data$i <- rep(1:ni, times = np*nh) #line of change
sim_data$h <- rep(1:nh, each = ni, times = np)
results <- matrix(0,nrow = 1000, ncol = 5)
for (i in 1:1000){
#Create random effects (generate new for each replication)
Zp <- rnorm(np, 0, 1)
Zh <- rnorm(nh, 0, 1)
Zph <- matrix(rnorm(np*nh, 0, 1), nrow = np, ncol = nh)
Zi.h <- matrix(rnorm(ni*nh, 0, 1), nrow = ni, ncol = nh)
#Simulate Scores
score_index <- 1
for (p_ in 1:np) { #using underscores to differentiate index from variable name
for (h_ in 1:nh) {
for (i_ in 1:ni) {
Score_pih <- sig_p*Zp[p_] +
sig_h*Zh[h_] +
sig_ph*Zph[p_,h_] +
sig_i.h*Zi.h[i_,h_] +
sig_pi.h*rnorm(1)
sim_data$Score[score_index] <- Score_pih
score_index <- score_index + 1
}
}
}
formula <- Score ~ (1|p)+(1|p:h)+ (1|h/i)
g <- gstudy(data = sim_data, formula)
results[i,] <- g$components[,2]
}
colMeans(results)
np <- 100 #persons
ni <- 20 #items PER RATER
nh <- 2 #raters
ni.h <- ni/nh #number of i within each h
#set true parameter values to those in Table 7 of Tong & Brennan
sig_p <- 4
sig_h <- 1
sig_ph <- sqrt(2)
sig_i.h <- sqrt(7)
sig_pi.h <- sqrt(208)
#Construct design matrix (only needs to be done once)
sim_data <- data.frame(matrix(0, np*ni*nh, ncol = 4))
colnames(sim_data) <- c("p","i","h","Score")
sim_data$p <- rep(1:np, each = ni*nh)
sim_data$i <- rep(1:ni, times = np*nh) # changed this line
sim_data$h <- rep(1:nh, each = ni, times = np)
results_all <- NULL
registerDoParallel(cores = 4)
ptm <- proc.time()
r <- foreach(icount(50), .combine = rbind) %dopar% {
# Create random effects (generate new for each replication)
Zp <- rnorm(np, 0, 1)
Zh <- rnorm(nh, 0, 1)
Zph <- matrix(rnorm(np*nh, 0, 1), nrow = np, ncol = nh)
Zi.h <- matrix(rnorm(ni*nh, 0, 1), nrow = ni, ncol = nh)
#Simulate Scores
score_index <- 1
for (p_ in 1:np) { #using underscores to differentiate index from variable name
for (h_ in 1:nh) {
for (i_ in 1:ni) {
Score_pih <- sig_p*Zp[p_] +
sig_h*Zh[h_] +
sig_ph*Zph[p_,h_] +
sig_i.h*Zi.h[i_,h_] +
sig_pi.h*rnorm(1)
sim_data$Score[score_index] <- Score_pih
score_index <- score_index + 1
}
}
}
result <- NULL
result <- c(summaryCINested(CalcGTheoryCINested(sim_data, 100, type = "p"), 0.8, 4)$Gstudy_Estimates, summaryCINested(CalcGTheoryCINested(sim_data, 100, type = "o"), 0.8, 4)$Gstudy_Estimates, summaryCINested(CalcGTheoryCINested(sim_data, 100, type = "po"), 0.8, 4)$Gstudy_Estimates, summaryCINested(CalcGTheoryCINested(sim_data, 100, type = "io"), 0.8, 4)$Gstudy_Estimates, summaryCINested(CalcGTheoryCINested(sim_data, 100, type = "pio"), 0.8, 4)$Gstudy_Estimates)
result
}
results_all <- rbind(results_all, r)
final <- colMeans(results_all)
sim_result_mean <- rbind(c(final[1:5]),c(final[11:15]),c(final[21:25]),c(final[31:35]),c(final[41:45]))
sim_result_SE <- rbind(c(final[6:10]),c(final[16:20]),c(final[26:30]),c(final[36:40]),c(final[46:50]))
colnames(sim_result_mean) <- c("p Var", "o Var", "po Var",
"i:o Var", "ResidVar")
colnames(sim_result_SE) <- c("p Var_SE", "o Var_SE",
"po Var_SE", "i:o Var_SE", "ResidVar_SE")
rownames(sim_result_mean) <- c("boot-p","boot-o","boot-p,o","boot-i,o","boot-p,i,o")
rownames(sim_result_SE) <- c("boot-p","boot-o","boot-p,o","boot-i,o","boot-p,i,o")
list(Mean_Estimates = sim_result_mean, SE_Estimates = sim_result_SE)
proc.time() - ptm
summaryCINested(CalcGTheoryCINested(sim_data, 100, type = "p"), 0.8, 4)$Gstudy_Estimates
summaryCINested(CalcGTheoryCINested(Data = Brennan.3.1, B = 1000, type = "po"))
summaryCINested(CalcGTheoryCINested(Data = Brennan.3.1, B = 1000, type = "po"))$Gstudy_Estimates
summaryCINested(CalcGTheoryCINested(Data = Brennan.3.1, B = 1000, type = "po"))$Gstudy_Estimates[,1]
